<script lang="ts">
	import { useRawImage } from '$lib/state/currentRawImage';

	//TODO: and need to expose functions which can control the canvas i.e. (resetScale) for if we want to use a rotate tool
	const { rawImage, rawImageRGBA } = useRawImage();

	const canvasLogger = (...args: any[]) => console.log('%c CANVAS', 'color: yellow', ...args);

	$effect(() => {
		console.log('rawImage', $rawImage);
	});

	let imageBoundingArea = $state({ width: 0, height: 0 });

	let imageSource: HTMLCanvasElement | undefined = $state();
	$effect(() => {
		if ($rawImageRGBA && $rawImage) {
			canvasLogger('Redrawing image source');
			const canvas = document.createElement('canvas');
			// Set the image source to be the size as the raw image
			canvas.width = $rawImage.width;
			canvas.height = $rawImage.height;

			const ctx = canvas.getContext('2d');
			if (!ctx) {
				throw new Error('Could not get context');
			}
			const imageData = ctx.createImageData($rawImage.width, $rawImage.height);
			// this is not using state atm, so beware of diverging data (shouldnt tho)
			imageData.data.set($rawImageRGBA);
			ctx.reset();
			ctx.putImageData(imageData, 0, 0);
			imageSource = canvas;
		}
	});

	let scaledImageSource: HTMLCanvasElement | undefined = $state();
	$effect(() => {
		if (imageSource) {
			canvasLogger('Redrawing scaled image source');
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');
			if (!ctx) {
				throw new Error('Could not get context');
			}
			// fit this canvas to the bounding area
			canvas.width = imageBoundingArea.width;
			canvas.height = imageBoundingArea.height;
			const goodFitDimensions = getGoodFitDimensions(imageSource, canvas);
			ctx.reset();
			ctx.drawImage(
				imageSource,
				goodFitDimensions.x,
				goodFitDimensions.y,
				goodFitDimensions.width,
				goodFitDimensions.height
			);
			scaledImageSource = canvas;
		}
	});

	let interactionCanvas: HTMLCanvasElement | undefined;
	$effect(() => {
		if (scaledImageSource && interactionCanvas) {
			canvasLogger('Redrawing interaction canvas');
			const ctx = interactionCanvas.getContext('2d');
			if (!ctx) {
				throw new Error('Could not get context');
			}
			interactionCanvas.width = window.innerWidth;
			interactionCanvas.height = window.innerHeight;
			ctx.reset();
			// render the scaled canvas into the overflow canvas, so that we can pan, zoom, across the whole viewport
			// since we already scaled and positioned with imageCanvas, we can just render to 0,0
			ctx.drawImage(scaledImageSource, 0, 0);
		}
	});

	const getGoodFitDimensions = <Dimensions extends { width: number; height: number }>(
		imageDimensions: Dimensions,
		canvasDimensions: Dimensions
	) => {
		const containerW = canvasDimensions.width;
		const containerH = canvasDimensions.height;
		const imageAspectRatio = imageDimensions.width / imageDimensions.height;

		const containerAspectRatio = containerW / containerH;

		// x and y positions to centre the image
		let outputWidth, outputHeight, x, y;

		if (imageAspectRatio > containerAspectRatio) {
			// width fills container
			outputWidth = containerW;
			outputHeight = containerW / imageAspectRatio;
			x = 0;
			y = (containerH - outputHeight) / 2;
		} else {
			// height fills container
			outputWidth = containerH * imageAspectRatio;
			outputHeight = containerH;
			x = (containerW - outputWidth) / 2;
			y = 0;
		}

		return { width: outputWidth, height: outputHeight, x, y };
	};
</script>

<!-- ðŸ‘‡ This div will fill the parent container, to provide us with the correct space to initially scale the image into -->
<!-- This also updates when the parent container changes size, no resize handler needed ðŸŽ‰ -->
<div
	class="image-bounding-area"
	bind:clientWidth={imageBoundingArea.width}
	bind:clientHeight={imageBoundingArea.height}
></div>
<canvas bind:this={interactionCanvas} class="interaction-canvas"></canvas>

<style>
	.image-bounding-area {
		width: 100%;
		height: 100%;
	}
	.interaction-canvas {
		position: absolute;
		top: 0;
		left: 0;
		height: 100%;
		width: 100%;
		z-index: var(--z-canvas);
	}
</style>
